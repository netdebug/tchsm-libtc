#include "tc.h"

#include <stdlib.h>
#include <string.h>
#include <mhash.h>

const byte MD2_PKCS_ID[] = {
    0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86,
    0xF7, 0x0D, 0x02, 0x02, 0x05, 0x00, 0x04, 0x10 };

const byte MD5_PKCS_ID[] = {
    0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86,
    0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10 };

const byte RIPEMD_128_PKCS_ID[] = {
    0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x24, 0x03, 0x02,
    0x02, 0x05, 0x00, 0x04, 0x14 };

const byte RIPEMD_160_PKCS_ID[] = {
    0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x24, 0x03, 0x02,
    0x01, 0x05, 0x00, 0x04, 0x14 };

const byte SHA_160_PKCS_ID[] = {
    0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02,
    0x1A, 0x05, 0x00, 0x04, 0x14 };

const byte SHA_224_PKCS_ID[] = {
    0x30, 0x2D, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
    0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1C };

const byte SHA_256_PKCS_ID[] = {
    0x30, 0x31, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
    0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20 };

const byte SHA_384_PKCS_ID[] = {
    0x30, 0x41, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
    0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30 };

const byte SHA_512_PKCS_ID[] = {
    0x30, 0x51, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
    0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40 };

const byte TIGER_PKCS_ID[] = {
    0x30, 0x29, 0x30, 0x0D, 0x06, 0x09, 0x2B, 0x06, 0x01, 0x04,
    0x01, 0xDA, 0x47, 0x0C, 0x02, 0x05, 0x00, 0x04, 0x18 };

static inline void get_hash_properties(const byte ** id, int * id_len, int * digest_len, tc_hash_type_t hash_type) {
    switch(hash_type) {
        case TC_SHA256:
            *id_len = sizeof(SHA_256_PKCS_ID);
            *digest_len = 256/8;
            *id = SHA_256_PKCS_ID;
            break;
        case TC_NONE:
            *id_len = 0;
            *digest_len = -1;
            *id = NULL;
            break;
        default:
            abort();
    }
}

static void tc_pkcs1_encoding(byte * out, const unsigned char * digest, tc_hash_type_t hash_type, int modulus_size) {
    int k = modulus_size;
    const byte * hash_desc;
    int hash_desc_len, digest_len;

    get_hash_properties(&hash_desc, &hash_desc_len, &digest_len, hash_type);

    int D_len = digest_len + hash_desc_len;
    int P_len = k - 3 - D_len;

    byte * p = out;
    /* PKCS1 padding */
    *p++ = 0x00;
    *p++ = 0x01;
    memset(p, 0xFF, P_len);
    p += P_len;
    *p++ = 0x00;

    if (hash_desc != NULL) { // ASN.1
       memcpy(p, hash_desc, hash_desc_len);
    }

    p += hash_desc_len;

    if (digest != NULL) {
        memcpy(p, digest, digest_len);
    }
}

void tc_prepare_document(bytes_t * out, const bytes_t * doc, tc_hash_type_t hash_type, const key_meta_info_t * metainfo) {
    out->data_len = metainfo->public_key->n.data_len;
    out->data = malloc(out->data_len);

    switch(hash_type) {
        case TC_SHA256:
            {
                byte hash[32];
                MHASH sha = mhash_init(MHASH_SHA256);
                mhash(sha, doc->data, doc->data_len);
                mhash_deinit(sha, hash);

                tc_pkcs1_encoding(out->data, hash, TC_SHA256, out->data_len);

            }
            break;
        case TC_NONE:
            tc_pkcs1_encoding(out->data, doc->data, TC_NONE, out->data_len);
            break;
    };

}
